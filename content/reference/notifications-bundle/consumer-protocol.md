---
weight: 30
title: Consumer protocol
layout: bundle
outputs:
- html
- json
---
<a name="consumer-protocol">&nbsp;</a>

The {{< product-c8y-iot >}} Notifications 2.0 API uses a secure [WebSocket](https://en.wikipedia.org/wiki/WebSocket) to consume notifications generated by the {{< product-c8y-iot >}} API.

The new endpoint is accessible using the external {{< product-c8y-iot >}} fully qualified domain name of your {{< product-c8y-iot >}} environment and the standard SSL port 443 using a secure WebSocket connection. It is also available on the unsecured port 80 and to microservices using "cumulocity:8111" but in most cases a secure connection is preferred.

The [URI scheme](https://en.wikipedia.org/wiki/List_of_URI_schemes) therefore is "wss" and consumers use URLs starting with "wss://" followed by the fully qualified domain name of the {{< product-c8y-iot >}} environment or tenant, followed by a fixed URL path and a query string.

The fixed URL path is <kbd>/notification2/consumer/</kbd> and there are only two query string arguments:

* `token` (required). Its value must be a valid token in the form of a JWT token string as returned by a create token request to the [Tokens methods](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Tokens) of the Notifications 2.0 API. Including the token as a query string parameter avoids having to set an HTTP header which can be an issue for some WebSocket clients or proxies.

* `consumer` (optional). Its value is a non blank unique name for the consumer. 

In summary, the URLs used by consumers follow the following patterns:

```
wss://your.{{< product-c8y >}}.environment.fullqualifieddomainname/notification2/consumer/?token=yourJwtTokenRequestedFromNotification2TokenService
```

or

```
wss://your.{{< product-c8y >}}.environment.fullqualifieddomainname/notification2/consumer/?token=yourJwtTokenRequestedFromNotification2TokenService&consumer=aUniqueNameForThisConsumer
```

### WebSocket timeouts

There is a timeout of 5 minutes set on idle WebSocket connections after which the connection will be closed by the server side. Therefore the consumer must be prepared to handle closed connections which is required for fault tolerant operation in any case. All consuming microservices or applications should handle the WebSocket being closed and re-connect as necessary.

<a name="notification-acknowledgements">&nbsp;</a>
### Notification acknowledgements
The WebSocket service sends a sequence of UTF-8 encoded textual notification messages to the consumer.
Each notification message includes headers and a data payload.
Headers occur first in the message and are separated by new line characters. The data payload is last in the message,
separated from the last header by 2 new line characters, showing one blank line between the last header and the payload.
The first header in the message is always the acknowledgement header. 

When the client has finished processing a notification message,
it must send that message's acknowledgement header back to the server on the same connection the message was received on. 
Sending the acknowledgement tells the server that the consumer has successfully received and processed that message, 
allowing the server to forget the message.
Each acknowledgement is unique to a particular notification and consumer. Note that batch and cumulative acknowledgements are not supported.

If too many of a consumer's notifications (1000 by default) remain unacknowledged, 
the flow of notification messages to that consumer will stop until some of its unacknowledged messages are acknowledged.
It is therefore best practise to process and acknowledge them quickly, to minimise the potential for a connection interruption causing a need to redeliver them.
An acknowledgement should not be sent until its notification has been successfully processed.
Otherwise, for example, if the client crashed during or before such processing,
the message may be lost as acknowledged messages are not (usually) resent by the server.

The hello-world-notification-microservice example in the [cumulocity-examples repository](https://github.com/SoftwareAG/cumulocity-examples/tree/develop/hello-world-notification-microservice)
shows an example of how to send the acknowledgement back to the server in a self-contained WebSocket text message. 
It should be sent without quotation marks, as it is not a JSON message, and without any trailing new-line characters.

### Notification message header and content

A notification (transmitted service to client) consists of a header and a body (similar to an HTTP request).
The header is one or more (in practice at least 3) lines of text, separated by a `\n` (newline) character.
The end of the header is demarcated by a double new line `\n\n`.

The notification body follows the header.
This also consists of UTF text - for example a JSON document.
If the notification is binary data or includes binary data then it will be [Base64 encoded](https://en.wikipedia.org/wiki/Base64).

The header lines for a notification are as follows (separated by `\n` newlines):

* Required message identifier for message acknowledgement. This opaque value is an encoded binary 64 bit value. 
  After the consumer has finished processing a notification, it must send this header back to the server to [acknowledge the notification](../notifications/#notification-acknowledgements).

* The [notification description](../notifications/#notification-description-header) on the second header line. This is a string describing what type of notification this is and its source. Measurements ("measurements"), events ("events") and alarms ("alarms") are examples of notifications, as are inventory creates, updates and deletes ("managedObjects"). There is a direct correspondence with realtime notifications which features similar notification descriptions. These are not enumerated here and are expected to increase in number in the future. For REST API notifications, they follow a three-part format, separated by "/". For more details on notification descriptions see [Notification description header](#notification-description-header) .

* An action string is the third header. Examples are CREATE, UPDATE and DELETE. More actions may be added in the future. Together with the notification type they describe the logical event that generated the notification, such as a CREATE of an alarm or measurement.

Depending on the second header there may be further headers to follow but currently notifications only use the above three.
In order to be future proof and forward compatible, we encourage consumer code to cope with more headers by parsing them out but ignoring them.

See the *hello-world-notification-microservice* example in the [cumulocity-examples repository](https://github.com/SoftwareAG/cumulocity-examples/tree/develop/hello-world-notification-microservice) on how to do this.

After the headers, the notification body follows as UTF-8 text. This is typically a JSON document.

<a name="notification-description-header">&nbsp;</a>
#### Notification description header

The second header line is the notification description string in the form of a `/`-separated path. For API notifications descriptions have three parts: tenantId, type and sourceId.

* tenantId - this the identifier for the tenant under which the notification was generated.
* type - the platform type of notification generated. For example, event, measurement, alarm or managed object.
* sourceId - the identifier of the "source" object that generated or is the subject of the notification. Source is a very loose term here, much as in "event sourcing" but generally indicates which managed object the notification is about.

Some examples are provided in [Traces](#traces) and backwards compatibility to real-time notifications is provided for.


### Dealing with notification duplication
When a WebSocket connection is lost, whether that is due to deliberate connection closure or connection failure,
messages that were received but not successfully acknowledged before the connection loss are sent to the consumer again when it reconnects.
This can result in duplicate messages being received by the consumer. 
Those duplicates can sometimes include acknowledged messages as these may be on-the-wire from the consumer to the server when the connection is lost.

Notification messages do not contain any specific unique identifiers to aid in de-duplication. 
Therefore, any de-duplication of messages must be done by the consumer based upon the [notification description header](../notifications/#notification-description-header) and payload.
Note that the acknowledgement header is not guaranteed to be unique across consumer reconnections, which is when duplicates are most likely.

Some events are easy to de-duplicate, such as inventory events where a unique source object is first created and then deleted. 
It will often be possible to use the notification message headers to determine these cases.
However, inventory updates or logically sequenced events such as alarms and measurements will typically require application-specific understanding of the payload fields.
Ideally the payload would include a field specifically for that purpose. If it is not possible to include such a field in the payload,
then other existing fields will have to be used, maybe on a best effort basis.

A specific field in the payload would typically be a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) or increasing sequence number. 
The latter may aid the efficiency of de-duplication by using ordering, 
though the sequence numbers will be unrelated across publishers, typically IoT devices, when the messages are originated from more than one publisher. 
Any messages received from the same publisher with a lower sequence number than the last one processed from that publisher can be quickly discarded, 
assuming the sequence has not rolled over. It is also easier for a human to understand that the ordering is correct and all messages are present.  
