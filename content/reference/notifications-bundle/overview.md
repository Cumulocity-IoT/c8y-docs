---
weight: 10
title: Overview
layout: redirect
---

The [Notifications 2.0 API](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Notification-2.0-API) allows applications or microservices to receive and process notifications generated by the use of the {{< product-c8y-iot >}} REST or MQTT APIs (device management, measurements, alarms, events and other platform APIs) in a reliable manner.

{{< c8y-admon-req >}}
The Cumulocity Messaging Service is an optional component of the {{< product-c8y-iot >}} platform that may need to be enabled before Notifications 2.0 can be used.
Changes to the configuration of the load balancer or ingress controller may also be required to allow access to the Websocket endpoint used by Notifications 2.0.

For the shared public cloud instances of the {{< product-c8y-iot >}} platform, the Messaging Service is enabled by default on release 10.13 and above.
For dedicated and self-hosted instances, the Messaging Service and Notifications 2.0 are available for release 10.11 and above, but will need to be explicitly enabled.

Please contact [product support](/welcome/contacting-support/) to inquire about using the Messaging Service and Notifications 2.0 capabilities in your {{< product-c8y-iot >}} environment.
See the *Messaging Service - Installation & operations guide* for further technical details of the configuration required, but note that these tasks can only be performed by a {{< product-c8y-iot >}} platform operator, not by a normal user.
{{< /c8y-admon-req >}}

Notifications 2.0 improves upon the [Real-time notification API](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Real-time-notification-API) by providing stronger delivery semantics and ordering guarantees.
It is also intended to be simpler to use than the "Bayeaux" protocol used in the Real-time notification API.
New capabilities are added to Notifications 2.0 in each release of {{< product-c8y-iot >}}.
However, it does not yet support all of the notifications available from the Real-time notification API so it is not yet a complete replacement for the older API.
See the rest of this section and the detailed API documentation for full details of the notifications supported by this release of the Notifications 2.0 API.

To receive notifications over the Notifications 2.0 protocol, an application or microservice must subscribe to notifications, either for notifications about a particular managed object or in a wider context that is scoped to a tenant. Subscriptions are persistent, long lived, and allow notifications to be stored reliably until consumed and acknowledged by a consuming microservice or application.

### Managed object context

For managed objects, an object's global identifier must be used to subscribe in the managed object context ("mo") in order to receive notifications.
There can be multiple subscriptions for the same subscribed object, with different filters or just to fan out to multiple interested consumer parties.

This subscribed object is known as the source object for the <kdb>notification/event</kdb> and it is referenced in the notifications delivered to subscribers.
Subscriptions are set up using the [subscription method](https://{{<domain-c8y>}}/api/core/{{< c8y-current-version >}}/#tag/Subscriptions) of the Notifications 2.0 API.
This API requires the calling user to be an authenticated {{< product-c8y-iot >}} user and to have the new ROLE_NOTIFICATION_2_ADMIN role.

When subscribing to notifications, a filter for notifications can be specified which determines the APIs (alarms, alarms with children, events, events with children, measurements, managed objects, operations, or any combination of these) to filter by. The alarms with children and events with children enable users to create explicit subscriptions that allow the delivery of child as well as parent managed object events and alarms.
It is also possible to filter by presence of a specific JSON fragment or "fragment type".
When matched, either the whole notification content is forwarded, or one or more fragments can be specified to be copied over to the consumer.
For usage, refer to the [{{< openapi >}}](https://{{<domain-c8y>}}/api/core/{{< c8y-current-version >}}/#operation/postNotificationSubscriptionResource).

### Receiving subscribed notifications

In order to receive subscribed notifications, a consumer application or microservice must obtain an authorization token that provides proof that the holder is allowed to receive subscribed notifications.

This token is in the form of a string conforming to the JWT (JSON Web Token) standard that is obtained from the [token method](https://{{<domain-c8y>}}/api/core/{{< c8y-current-version >}}/#tag/Tokens) of the Notifications 2.0 API.
This API requires the calling user to be an authenticated {{< product-c8y-iot >}} user and to have the new ROLE_NOTIFICATION_2_ADMIN role.

See the [{{< openapi >}}](https://{{<domain-c8y>}}/api/core/{{< c8y-current-version >}}/#tag/Tokens) for both the Notification 2.0 Subscription and Token API.

Once subscribed, notifications are persisted and available to be consumed using a new WebSocket-based protocol.
This protocol implements a reliable delivery with at-least-once semantics.
The underlying Messaging Service will repeatedly attempt to deliver a notification until that notification is acknowledged as being received and processed by the consuming application or microservice.
Notification order is preserved from the point of view of a device sending in REST and MQTT API requests.
The protocol is text-based and described in detail in the next section.

### Tenant context

The tenant context ("tenant") is used for subscribing to and receiving notifications, in addition to the managed object context ("mo") mentioned above.
Creations of managed objects, which generate a new object identifier that can act as a source for notifications are reported in the tenant context.
This allows an application to discover a new managed object, which can then choose to subscribe to in the managed object context.
It is also possible to subscribe to all alarms that are generated in the tenant context.

See the [{{< openapi >}}](https://{{<domain-c8y>}}/api/core/{{< c8y-current-version >}}/#tag/Subscriptions) on how to subscribe to these notifications, additionally filtering the notification of interest.

For the protocol consumer, both managed object creations and alarms subscribed under the tenant context are reported in the same way.
There is no distinction between the two contexts for consumers, and notification ordering is maintained between the two contexts.

### Building consuming microservices and applications

For Java developers, the API and the protocol have been wrapped up as an open Java API and a sample WebSocket client application. Any WebSocket library or programming language can be used as the protocol is text-based and relatively simple. Consumer can be either microservices or applications running externally from {{< product-c8y-iot >}} and require only a JWT string when connecting.

There is a sample microservice available in the [cumulocity-examples repository](https://github.com/SoftwareAG/cumulocity-examples/tree/develop/hello-world-notification-microservice), so Java developers do not need to code to the protocol specification directly.

### Token expiration

When creating a token, an expiration time must be given in minutes of validity from when the token was created.
This security feature limits the potential damage due to leaking of a token.
It requires tokens to be re-created or refreshed periodically.
This can be done by calling the token create request with the same parameters as originally.
If the parameters used are not available they can be extracted from the token.
As the token string is a JWT (JSON Web Token), it can be decoded to extract the original information used to create the token by splitting it into 3 parts (on ".") and doing a base64 decode on the first substring.
This way, information like the subscription name can be extracted and the create token REST point can be called again, all on the client side.
The {{< product-c8y-iot >}} microservice Java SDK [TokenApi](https://github.com/SoftwareAG/cumulocity-clients-java/blob/develop/java-client/src/main/java/com/cumulocity/sdk/client/messaging/notifications/TokenApi.java) class contains a public refresh method which is implemented purely on the client side.

### Deleting subscriptions and unsubscribing a subscriber

Once a subscription is made, notifications will be retained until consumed by all subscribers who have previously connected to the subscription.
The normal workflow is to delete subscriptions when no longer interested in notifications and this is the resonsibility of the subscriber.
The subscription API [{{< openapi >}}](https://{{<domain-c8y>}}/api/core/{{< c8y-current-version >}}/#tag/Subscriptions) is used to delete subscriptions.
After the subscription is deleted no more notifications will be saved. The consuming microservice or application can then drain down notifications
and be removed when that is done.

However, unconsumed notifications will be retained, and for high throughput scenarios this can result in notifications remaining in storage
if never consumed by the application.
They will be deleted if a tenant is deleted but otherwise can take up considerable space in permanent storage for high frequency notification sources.
It is therefore advisable to unsubscribe a subscriber that will never run again.
A separate REST endpoint is available for this: <kbd>/notification2/unsubscribe</kbd>.
It has a mandatory query parameter `token`.
The token is the same as you would use to connect to the WebSocket endpoint to consume notifications.
Note that there is no explicit "subscribe a subscriber" operation using a token.
Instead this happens when you first connect a WebSocket with a token for the subscription name and subscriber.
However, unsubscribing a microservice or an application is an explicit act using the original or a similar token.
Unsubscribing should be infrequent, for example when deleting an application or during development when testing completes,
as typically one wants messages to persist even when no consumer is running.
Only if no consumer will ever run again to drain notifications should unsubscribing a subscriber be necessary.

It is also possible to unsubscribe a subscriber on an open consumer WebSocket connection.
To do so, send `unsubscribe_subscriber` instead of a message acknowledgement identifier from your WebSocket client to the service.
The service will then unsubscribe the subscriber and close the connection.
It's not possible to check if the unsubscribe operation succeeded as the connection always closes so this way of unsubscribing is mostly for testing.

It is always important to delete subscriptions (Delete operations on `/notification2/subscriptions`) even having unsubscribed, as otherwise notifications will be generated even if no subscriptions remain. While they would not persist, load and network traffic would still be incurred.
