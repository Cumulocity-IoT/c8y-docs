---
weight: 10
title: Overview
layout: redirect
---

The [Notifications 2.0 API](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Notification-2.0-API) allows applications or microservices to receive and process notifications generated by the use of the {{< product-c8y-iot >}} REST or MQTT APIs (device management, measurements, alarms, events and other platform APIs) in a reliable manner.

{{< c8y-admon-req >}}
The Cumulocity Messaging Service is an optional component of the {{< product-c8y-iot >}} platform that may need to be enabled before Notifications 2.0 can be used.
Changes to the configuration of the load balancer or ingress controller may also be required to allow access to the Websocket endpoint used by Notifications 2.0.

For the shared public cloud instances of the {{< product-c8y-iot >}} platform, the Messaging Service is enabled by default on release 10.13 and above.
For dedicated and self-hosted instances, the Messaging Service and Notifications 2.0 are available for release 10.11 and above, but will need to be explicitly enabled.

Please contact [product support](/welcome/contacting-support/) to inquire about using the Messaging Service and Notifications 2.0 capabilities in your {{< product-c8y-iot >}} environment.
See the *Messaging Service - Installation & operations guide* for further technical details of the configuration required, but note that these tasks can only be performed by a {{< product-c8y-iot >}} platform operator, not by a normal user.

ROLES & PERMISSIONS:

* To view and manage Notifications 2.0 subscriptions (read, create, delete): ADMIN permission for the permission type "Notification 2". 

{{< /c8y-admon-req >}}

Notifications 2.0 improves upon the [Real-time notification API](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Real-time-notification-API) by providing stronger delivery semantics and ordering guarantees.
It is also intended to be simpler to use than the "Bayeaux" protocol used in the Real-time notification API.
New capabilities are added to Notifications 2.0 in each release of {{< product-c8y-iot >}}.
However, it does not yet support all of the notifications available from the Real-time notification API so it is not yet a complete replacement for the older API.
See the rest of this section and the detailed API documentation for full details of the notifications supported by this release of the Notifications 2.0 API.

### Topics and subscriptions
Internally, Notifications 2.0 uses a [publish-subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)
pattern, allowing use-cases to organise their desired selections of measurement, event, alarm, operations and/or inventory messages 
into topics according to functional interest.
Creating a Notification 2.0 [subscription](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#tag/Subscriptions)
in {{< product-c8y-iot >}} creates a publisher (internally), that will forward {{< product-c8y-iot >}} messages that it matches (based
on message qualities such as its source, type or even content, for example) to a specific topic. 
Each subscription can only forward messages to one topic, but multiple subscriptions can forward messages to the same topic.

{{< c8y-admon-caution >}}
The term 'subscription' is overloaded and can be confusing here.
It is called a subscription as internally the topic is subscribing to a selection of {{< product-c8y-iot >}} messages - it does not relate to a Notification 2.0 end consumer.
This may be revised in a future release to avoid potential confusion.
{{< /c8y-admon-caution >}}

The diagram 'Notification 2.0 topics and subscriptions' immediately following shows
three subscriptions that have been created in {{< product-c8y-iot >}} that are forwarding notification messages into two topics in the Messaging Service.

The 'temperature' topic is receiving measurements from the leftmost and centrally depicted subscriptions.
Both of these have a "mo" (managed object) context and they both include messages from the measurement API only.
A subscription with a managed object context can only forward messages from a specific managed object (such as a device).
The leftmost subscription is forwarding measurements from a device with source id '12345' and
the centrally depicted one the same but from device '67890'.

The 'alarms' topic is receiving alarms from the rightmost subscription. It has a tenant context and includes messages from 
the alarm api. It will forward all alarms within the tenant that creates the subscription, regardless of how they are generated 
(finer grained topics can be created using filters).
The forwarded alarms will include those raised by {{< product-c8y-iot >}} itself, and those published via REST or MQTT from other components in, or attached to,
the platform, including any alarms raised by the depicted devices.

![Notification 2.0 topics and subscriptions diagram](/images/reference-guide/notification2/notification2-subscriptions.svg)

### Consumers and tokens
A topic's notification messages can be received by WebSocket based consumers that present a valid authorizing
token for that specific topic when connecting to the Notification 2.0 WebSocket endpoint.
This token is in the form of a string conforming to the JWT (JSON Web Token) standard. Tokens can be obtained from the
{{< product-c8y-iot >}}  [token](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#tag/Tokens) REST API by authenticated users.

Consumers receive the topic messages reliably, with at-least-once semantics, in order and must acknowledge each message in turn.
Notification order is preserved from the point of view of any given device sending in REST and MQTT API requests.
The protocol is text-based and described in detail in the [Consumer protocol](../notifications/#consumer-protocol) section.
In typical usage, multiple consumers of a given topic operate independently in parallel, each receiving and acknowledging
separate copies of those messages.

{{< c8y-admon-caution >}}
It is important to manage consumers carefully as they can place significant storage resource demands on a system.
Consumers should only be created (connected) if they are to be active, 
and should be unsubscribed if they are no longer needed or not needed for long periods.
Unsubscribing is an explicit action - disconnecting a consumer client does *not* unsubscribe it.
See the [Consumer lifecycle](../notifications/#consumer-lifecycle) section for more details.
{{< /c8y-admon-caution >}}

The diagram below shows 3 consumers that have been created in the Messaging Service by four consumer clients.

The rightmost client identifies its consumer as 'alarmmonitor" and that consumer receives messages from the "alarms" subscription topic. 

The second to right client identifies its consumer as 'tempaudit" and that consumer receives messages from the "temperature" subscription topic.

The leftmost two consumer clients are two shares of a (logically single) [shared consumer](../notifications/#shared-tokens),
and so share the same copy of topic messages. They both identify the same "tempmonitor" consumer; each receives a non-overlapping subset
of the messages in the "temperature" topic.
Collectively, they receive all of the messages in the topic.

![Notification 2.0 consumers and consumer clients diagram](/images/reference-guide/notification2/notification2-consumers.svg)

<a name="consumer-lifecycle">&nbsp;</a>
### Consumer lifecycle

When a subscription is created, {{< product-c8y-iot >}} starts to create and forward notifications within the subscription's scope 
to the Messaging Service subsystem. The Message Service does not necessarily retain these messages; it only retains a 
subscription topic's messages if the topic is persistent and it has at least one known consumer.

{{< c8y-admon-info >}}
Only consumers of persistent subscription topics have backlogs that are maintained across client reconnections.

Consumers of non-persistent subscription topics get a new backlog pointing only to the next (latest) topic message when 
they connect/reconnect and any previous backlog is discarded, removing any message references. They can only cause
backlog size problems if they remain connected but continually consume at a rate lower than the rate that new messages arrive.
{{< /c8y-admon-info >}}

Persistent subscription topic messages are only stored once in the Messaging Service, but all associated consumers' backlogs, 
whether the consumer is connected or not, reference each message until they have received and acknowledged it. 
Therefore, all consumer backlogs should be considered to have a storage cost from when they first connect until 
they explicitly express no further interest in the topic by unsubscribing.
The Messaging Service discards a given message only when there are no backlogs that reference it anymore.

The following diagram shows the lifecycle of a consumer backlog in relation to its associated client connection(s).
The backlog is created when the consumer first connects to the Messaging Service and is only destroyed when it is explicitly unsubscribed.
The consumer's backlog is maintained, even if its client connection is interrupted. This is needed for reliable messaging, 
allowing the consumer to not miss messages during connection outages, but comes at a cost of explicit lifecycle management.

![Notification 2.0 consumer backlog lifecycle](/images/reference-guide/notification2/notifications2-backlog-lifecycle.svg)

There are two ways unsubscribe a consumer:
* Pass the token as the **token** parameter to the
  [/notification2/unsubscribe](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#operation/postNotificationTokenUnsubscribeResource) REST endpoint.
* Send the message `unsubscribe_subscriber` from the consumer's connected WebSocket client.
  This will unsubscribe the consumer and close the connection (as shown in the diagram above). If the client experiences
  a connection failure while unsubscribing in this manner, there is no way to be certain the unsubscribe message was 
  successfully received and processed by the Messaging Service.
  Therefore, under such circumstances, the client should always reconnect and send the message again to be sure the
  unsubscribe action has taken effect.


### Creating subscriptions
The JSON fields sent in a [create subscription request](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#operation/postNotificationSubscriptionResource)
determine which {{< product-c8y-iot >}} messages are forwarded to a topic, and the forwarded message content.
This request must be made by an authenticated {{< product-c8y-iot >}} user with the `ROLE_NOTIFICATION_2_ADMIN` role.

The **context** field broadly determines the type of {{< product-c8y-iot >}} message a subscription might match and forward.
There are two valid **context** values: "mo" (managed object) and "tenant". Some subscription fields have 
constraints that vary according to the value of the **context** field. Where this is the case, it is pointed out in that field's 
documentation in the [create subscription](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#operation/postNotificationSubscriptionResource) documentation.

The **source** field can only be used if the **context** is "mo". It must have a nested **id** field containing the 
value of a managed object's global identifier (sometimes referred to as a 'device id' or 'source id').
This is used to target inclusion of messages from the given managed object.

**subscription** is the first of two fields that identify which topic this subscription will forward messages to.
Multiple subscriptions will contribute to a single topic if they have they same values for both the **subscription** and **nonPersistent** fields.

The **nonPersistent** field determines if the topic is [persistent or nonPersistent](../notifications/#non-persistent-topics).
Subscriptions with the same **subscription** field value, but different **nonPersistent** values forward to two different topics.
It is, therefore, the second of the two fields that identify the subscription topic. 

The **filter** field can provide a [subscription filter](../notifications/#subscription-filter), allowing more finely 
grained selection of the included messages, based upon the message **type** and API (is it a measurement or alarm, for example). 

The **fragmentsToCopy** field allows the forwarded messages to be transformed so that they contain only a specific subset
of the fragments present in the original {{< product-c8y-iot >}} messages they are generated from. This can be useful, for example,
for security, bandwidth saving or functionality scoping reasons. 

The following summarizes the subscription fields.
<table>
<thead>
<tr>
<th nowrap="nowrap">Field Name&nbsp;</th>
<th>Value</th>
<th>Required/Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td nowrap="nowrap">context</td>
<td>"mo" or "tenant"</td>
<td>Required</td>
<td>Only values "mo" and "tenant" are supported</td>
</tr>
<tr>
<td nowrap="nowrap">source</td>
<td>A managed object global identifier</td>
<td>Required if context is "mo"</td>
<td>Has a mandatory child <b>id</b> field</td>
</tr>
<tr>
<td nowrap="nowrap">subscription</td>
<td>String</td>
<td>Required</td>
<td>Determines messaging-service topic used</td>
</tr>
<tr>
<td nowrap="nowrap">nonPersistent</td>
<td>Boolean</td>
<td>false</td>
<td>Determines if a persistent or non-persistent topic is used</td>
</tr>
<tr>
<td nowrap="nowrap">filter</td>
<td>JSON object</td>
<td>All messages</td>
<td>Includes messages based on message values</td>
</tr>
<tr>
<td nowrap="nowrap">fragmentsToCopy</td>
<td>JSON list of strings</td>
<td>All fragments</td>
<td>Determines which fragments are included in forwarded messages.</td>
</tr>
</tbody>
</table>

Notifications for new managed objects creations can never be forwarded by subscriptions with an "mo" **context** as the 
managed object is only given an id when it is created and that id is needed as a field to create the subscription.
Therefore, to receive notifications informing of new managed object creations, a subscription with "tenant" **context** 
must be created to listen for them.
An application can use this to discover new managed objects.
It can then choose to create subscriptions with "mo" **context** for those managed objects.
It is also possible to subscribe to all alarms or events that are generated in a tenant using "tenant" **context**.

Notifications for managed object deletions will be forwarded to topics by subscriptions with "mo" (managed object) **context** 
that include the "managedobjects" API, and by subscriptions with "tenant" **context** that include the "managedobjects" API.

<a name="subscription-filter">&nbsp;</a>
### Subscription filters
Subscription filters provide fine-grained selection of the {{< product-c8y-iot >}} messages a subscription will forward.
Filters can be provided as the **subscriptionFilter** field in a subscription's JSON object at creation time. 
It is a JSON object with **apis** and **typeFilter** fields.  
Filters specified by subscriptions with "tenant" **context** *must* provide a **typeFilter** value.
Filters specified by those with "mo" **context** can provide either or both filter fields.

The **apis** field is a JSON array that specifies which {{< product-c8y-iot >}} API messages to include.
Use an array containing just the wildcard value, "*", to include messages from all APIs. 
To include messages from a subset of the APIs, use an array containing any single or multiple selection from 
"alarms", "alarmsWithChildren", "events", "eventsWithChildren", "measurements", "managedobjects" and "operations".

For example, to include messages from all APIs:
```json
{
  "context": "mo",
  "subscription": "subscription01",
  "source": {
    "id": 2468
  },
  "filter": {
    "apis": ["*"]
  }
}
```

To include only messages from the measurements and alarms APIs:
```json
{
  "context": "mo",
  "subscription": "subscription02",
  "source": {
    "id": 2468
  },
  "filter": {
    "apis": ["measurements", "alarms"]
  }
}
```

The "alarmsWithChildren" and "eventsWithChildren" **apis** values allow subscriptions with managed object **context**
to filter in, respectively, alarms or events for all recursively descendant child managed objects of the **source.id**
managed object in addition to inclusion of those from the **source.id** managed object itself.

The **typeFilter** string field is matched against the original message's **type** field. It can be a single value, or a
limited (supporting only `or`) [OData](https://en.wikipedia.org/wiki/Open_Data_Protocol) expression.

For example, to include messages with **type** "temperature" and messages with **type** "pressure":
```json
{
  "context": "mo",
  "subscription": "subscription03",
  "source": {
    "id": 2468
  },
  "filter": {
    "type": "'temperature' or 'pressure'"
  }
}
```
To include messages of **type** "temperature" only:
```json
{
  "context": "mo",
  "subscription": "subscription04",
  "source": {
    "id": 2468
  },
  "filter": {
    "type": "temperature"
  }
}
```

<a name="non-persistent-topics">&nbsp;</a>
### Persistent and non-persistent subscriptions 
A subscription can be persistent or non-persistent, implying that the Messaging Service topic for it is either persistent
or non-persistent, respectively.
These have different qualities which can be useful to satisfy the varying needs of differing use-cases. 


Persistent subscriptions are the default. They are used for reliable messaging, ensuring that consumers never miss a 
message if their connection is interrupted.
They use replicated secondary storage to maintain backlogs (within the constraints of any configured storage limits)
and to maintain the consumers' positions in their topics.
When a consumer of a persistent subscription topic has their connection interrupted,
whether that is due to network issues or deliberate actions by the consumer,
upon reconnection they will continue to receive notifications from the topic position they were at before the outage
(specifically, from the message after the last one they acknowledged successfully before the outage).

Non-persistent subscriptions are only buffered in memory. A client consumer's position is not persisted across
interruptions of the client connection.
When a consumer of a non-persistent subscription has their connection interrupted,
upon reconnection they will start receiving notifications from the most recent message of the subscription,
missing all other notifications that occurred during the connection outage.
This will be the case for all such temporarily disconnected consumers,
even if other consumers of the same non-persistent subscription
are still receiving older messages that occurred while it was not connected.

{{< c8y-admon-info >}}
If you create both a persistent and a non-persistent subscription with the same **subscription** field,
they are *separate*, independent subscriptions, backed by separate topics.

When creating a token for a non-persistent subscription topic, to access notifications from the correct topic, 
the token's **nonPersistent** field must be set to `true`.
As is the case for the subscription, this field defaults to `false`, meaning the token will be for a persistent 
subscription topic by default.
{{< /c8y-admon-info >}}

### Deleting subscriptions

Deleting a subscription will prevent it adding further notification messages to its associated topic. Many subscriptions 
can contribute notifications to a given topic so this does not control the topic lifecycle.
Deleting all the subscriptions associated with a topic will ensure no more notifications are added to it. This does not 
delete the topic either.

Even though the topic will no longer accumulate new messages, there may still be consumers draining 
the last of the messages from it. When all messages are consumed by all consumers, the topic will be empty and consume 
negligible space in the Messaging Service.

Subscriptions can be deleted by sending a [delete subscription request](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#operation/deleteNotificationSubscriptionResource), 
using the subscription's **id** as the URL filename. For example to delete subscription with id 8765:

```text
 DELETE /notification2/subscriptions/8765 HTTP/1.1
 Host: <HOST>
 Authentication: Basic: <AUTHENTICATION>
```

When a tenant is deleted from {{< product-c8y-iot >}}, all its subscriptions will be deleted. However, topics and consumers may 
still be active in the Messaging Service until all messages are consumed.

### Creating Tokens 
The JSON fields sent in a [create token request](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#operation/postNotificationTokenResource)
determine which subscription topic a consumer can receive messages from, the token's duration, 
the [shared](../notifications/#shared-tokens) nature of the consumer, and an identifier for the consumer.
This request must be made by an authenticated {{< product-c8y-iot >}} user with the `ROLE_NOTIFICATION_2_ADMIN` role.

The **subscription** field aligns with the same field in the subscription object, so broadly specifies the subscription
topic the consumer will receive notifications from. The **nonPersistent** field is also a factor in identifying the topic.

The **nonPersistent** field aligns with the same field in the subscription object so identifies whether the subscription topic
is [persistent or nonPersistent](../notifications/#non-persistent-topics) and therefore is a factor in identifying the topic only. 
There is no such thing as a peristent or non-peristent consumer 
and tokens cannot affect the nature they experience of topics using this field. 

The **subscriber** field provides a unique (within the scope of this topic) identity for the consumer, allowing 
it to be recognised across connection interruptions, so allowing message delivery to be resumed after such interruptions
and thus reliable.

The **shared** field determines if multiple clients can connect in parallel as the consumer identified in the 
**subscriber** field, acting collectively to share the notification message processing load.

The **expiresInMinutes** field is the period that this token will remain valid for, defaulting to "1440" minutes (1 day).

The following summarizes the token fields.
<table>
<thead>
<tr>
<th nowrap="nowrap">Field Name&nbsp;</th>
<th>Value</th>
<th>Required/Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td nowrap="nowrap">subscription</td>
<td>string</td>
<td>Required</td>
<td>Identifies topic</td>
</tr>
<tr>
<td nowrap="nowrap">nonPersistent</td>
<td>Boolean</td>
<td>false</td>
<td>Must be true to identify a nonPersistent topic</td>
</tr>
<tr>
<td nowrap="nowrap">subscriber</td>
<td>String</td>
<td>Required</td>
<td>Identifies the consumer bearing this token</td>
</tr>
<tr>
<td nowrap="nowrap">shared</td>
<td>Boolean</td>
<td>false</td>
<td>True if multiple clients can act collectively as this consumer.</td>
</tr>
<tr>
<td nowrap="nowrap">expiresInMinutes</td>
<td>Integer</td>
<td>1440</td>
<td>The token duration</td>
</tr>
</tbody>
</table>

### Token expiration

A token's lifetime is determined at creation time by the optional **expiresInMinutes** field, which defaults to "1440" (one day, expressed in minutes).
This can be used to limit exposure to potential security issues related to them being leaked to parties that should not be authorized to the access the system.
Consequently, tokens may need to be re-created or refreshed periodically.

Tokens can be refreshed by calling the token create request with the same parameters as originally 
(a different **expiresInMinutes** value can be given if a different duration is desired). 
The token string is a JWT (JSON Web Token) token so if the parameters used are not easily kept available, 
they can be extracted from the token string as outlined in Java code below:
```java
// The token string's sections are delimited by dots.
String[] tokenParts = token.split("\\.");
// Base64 decode the second section
byte[] decoded = Base64.getDecoder().decode(tokenParts[1]);
// Create a string from the decoded bytes to get a JSON string of the token fields
String tokenJson = new String(decoded);
// ... optionally create an Object from the string or bytes using a JSON  parser
```

If you are using the {{< product-c8y-iot >}} Java SDK [TokenApi](https://github.com/SoftwareAG/cumulocity-clients-java/blob/develop/java-client/src/main/java/com/cumulocity/sdk/client/messaging/notifications/TokenApi.java) 
class, it has a public refresh method which does the above for you, internally on the client side.

<a name="shared-tokens">&nbsp;</a>
### Shared consumer tokens

Shared consumer tokens allow parallelization of the consumer client workload.
This is useful if the notifications would otherwise arrive at a higher rate than a single consuming client application can process them.
It has no impact on the rate of notification throughput within, and thus their egress from, {{< product-c8y-iot >}} core.

When you create a token, you can add the optional Boolean body parameter `shared` to the request.
If it is set to `true`, the created token is shared.
If it is not present or `false`, the token is exclusive (not shared).

If a consumer's token is not shared, the consumer is an *exclusive* consumer.
Only one consumer client can connect using an exclusive token. An attempt to connect further consumers with the same exclusive token results in an error.
An exclusive consumer receives a copy of all notifications from the subscription topic its token is for.

If a consumer's token is shared, the consumer is a *shared consumer*. Additional consumer clients can connect using the same token.
If only one shared consumer client is connected, it receives a copy of all notifications from the subscription topic.
As additional consumer clients connect using the same token, the consumer notification load is rebalanced so that 
each consumer client receives a non-overlapping subset (share) of the notifications from the subscription topic. 
The set of consumer clients sharing a token can be thought of as a single logical consumer.
Collectively, the set receives all notifications for the subscription topic. 

The notification load is spread across the shared consumer clients according to the **id** of the source that generated the notification, typically a device **id**.
All notifications for a given **id** will be delivered to the same consumer. Each consumer may receive notifications for many different **id**s.
This means that there is no benefit using shared tokens unless the notifications feeding the subscription topic are coming from multiple sources.
Note that the load spreading algorithm may result in an asymmetric balance of notification load across the shares when there are few source **id**s in the subscription topic.
The load should generally become more evenly distributed as the number of sources increases.

In order to help keep the messages from a given set of source **id**s 'sticky' to a specific consumer client in the share in the face of connection interruptions,
the consumer clients can provide an optional `consumer` parameter in their connection URL string, in addition to their usual `token` parameter. 

For example: two consumers identifying themselves as *instance1* and *instance2* connect using URL paths
`notification2/consumer?token=xyz&consumer=instance1` and `notification2/consumer?token=xyz&consumer=instance2`.

Subscriptions are always unaware of the nature and number of their consumers: any number of shared and exclusive tokens 
can be created for the same subscription topic and they all operate independently, 
each receiving their own copy of the notifications.
This means you can have multiple shared tokens for the same subscription topic and their load is only divided within the scope of each shared token.

### Building consuming applications and microservices

A consumer client requires only a valid URL and JWT string to connect.
It can be implemented using any WebSocket library or programming language as the protocol is text-based and relatively simple.
The implementation can be a microservice running internally to, or an application running externally from, {{< product-c8y-iot >}}.

Java developers do not need to code to the protocol specification directly. 
The API and the protocol have been implemented in the [Cumulocity Clients Java API](https://github.com/SoftwareAG/cumulocity-clients-java/tree/develop/java-client/src/main/java/com/cumulocity/sdk/client/messaging/notifications)
. Examples using that can be found
in the [cumulocity-examples repository](https://github.com/SoftwareAG/cumulocity-examples/tree/develop/notification2-examples),
