---
weight: 10
title: Overview
layout: redirect
---

The [Notifications 2.0 API](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Notification-2.0-API) allows applications or microservices to receive and process notifications generated by the use of the {{< product-c8y-iot >}} REST or MQTT APIs (device management, measurements, alarms, events and other platform APIs) in a reliable manner.

{{< c8y-admon-req >}}
The Cumulocity Messaging Service is an optional component of the {{< product-c8y-iot >}} platform that may need to be enabled before Notifications 2.0 can be used.
Changes to the configuration of the load balancer or ingress controller may also be required to allow access to the Websocket endpoint used by Notifications 2.0.

For the shared public cloud instances of the {{< product-c8y-iot >}} platform, the Messaging Service is enabled by default on release 10.13 and above.
For dedicated and self-hosted instances, the Messaging Service and Notifications 2.0 are available for release 10.11 and above, but will need to be explicitly enabled.

Please contact [product support](/welcome/contacting-support/) to inquire about using the Messaging Service and Notifications 2.0 capabilities in your {{< product-c8y-iot >}} environment.
See the *Messaging Service - Installation & operations guide* for further technical details of the configuration required, but note that these tasks can only be performed by a {{< product-c8y-iot >}} platform operator, not by a normal user.

ROLES & PERMISSIONS:

* To view and manage Notifications 2.0 subscriptions (read, create, delete): ADMIN permission for the permission type "Notification 2". 

{{< /c8y-admon-req >}}

Notifications 2.0 improves upon the [Real-time notification API](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Real-time-notification-API) by providing stronger delivery semantics and ordering guarantees.
It is also intended to be simpler to use than the "Bayeaux" protocol used in the Real-time notification API.
New capabilities are added to Notifications 2.0 in each release of {{< product-c8y-iot >}}.
However, it does not yet support all of the notifications available from the Real-time notification API so it is not yet a complete replacement for the older API.
See the rest of this section and the detailed API documentation for full details of the notifications supported by this release of the Notifications 2.0 API.

### Topics and subscriptions
Internally, Notifications 2.0 uses a [publish-subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)
system, allowing use-cases to organise their desired selections of measurement, event, alarm and/or inventory messages 
into topics according to functional interest.
Creating a Notification 2.0 [subscription](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#tag/Subscriptions)
within {{< product-c8y-iot >}} creates a publisher (internally), that will forward {{< product-c8y-iot >}} messages that it matches (based 
on message qualities such as its source, type or even content, for example) to a specific topic. 
A single subscription can only forward messages to one topic, multiple subscriptions can forward messages to the same or different topics.

{{< c8y-admon-caution >}}
The term 'subscription' is overloaded and can be confusing here.
It is called a subscription as internally the topic is subscribing to a selection of {{< product-c8y-iot >}} messages - it does not relate to a Notification 2.0 end consumer.
This may be revised in a future release to avoid potential confusion.
{{< /c8y-admon-caution >}}

The diagram 'Notification 2.0 topics and subscriptions' immediately following shows
three subscriptions that have been created in {{< product-c8y-iot >}} that are forwarding notification messages into two topics in the messaging service.

The 'temperature' topic is receiving measurements from the leftmost and centrally depicted subscriptions.
Both of these have a managed-object context and they both include messages from the measurement api only.
A subscription with a managed-object context can only forward messages from a specific managed-object (such as a device).
The leftmost subscription is forwarding measurements from a device with source id '12345' and
the centrally depicted one the same but from device '67890'.

The 'alarms' topic is receiving alarms from the rightmost subscription. It has a tenant context and includes messages from 
the alarm api. It will forward all alarms within the tenant that creates the subscription, regardless of how they are generated 
(finer grained topics can be created using filters).
The forwarded alarms will include those raised by {{< product-c8y-iot >}} itself, and those published via REST or MQTT from other components in, or attached to,
the platform, including any alarms raised by the depicted devices.

![Notification 2.0 topics and subscriptions diagram](/images/reference-guide/notification2/notification2-subscriptions.svg)

### Consumers and tokens
A topic's notification messages can be received by WebSocket based consumers that present a valid authorizing
token for that specific topic when connecting to the Notification 2.0 WebSocket endpoint. Tokens can be obtained from the
{{< product-c8y-iot >}}  [token](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#tag/Tokens) REST API by authenticated users.
Consumers receive the topic messages reliably in order and must acknowledge each message in turn.
In typical usage, multiple consumers of a given topic operate independently in parallel, each receiving and acknowledging
separate copies of those messages.

{{< c8y-admon-caution >}}
It is important to manage consumers carefully, only creating (connecting) them if they are to be active,
and unsubscribing them if they are no longer needed or not needed for long periods.

A consumer resource is created in the messaging-service when a client bearing a token with a given 'subscriber' name connects for the first time.
That consumer will exist indefinitely or until explicitly
[unsubscribed](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#operation/postNotificationTokenUnsubscribeResource).
While they exist, consumers each have a backlog of the topic messages that they have not yet consumed.
If a consumer is not consuming a topic's notification messages promptly as they are generated, that consumer's backlog will grow, costing storage resource.
The higher the topic's notification rate is, the quicker those costs will increase.
{{< /c8y-admon-caution >}}

![Notification 2.0 consumers and consumer clients diagram](/images/reference-guide/notification2/notification2-consumers.svg)

### Creating subscriptions
The JSON fields sent in a [create subscription request](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#operation/postNotificationSubscriptionResource)
determine which {{< product-c8y-iot >}} messages are forwarded to a topic, and the forwarded message content.

The **context** field broadly determines the type of {{< product-c8y-iot >}} message a subscription might match and forward.
There are two valid **context** values: "mo" (managed-object) and "tenant" and each only supports a subset of the available JSON fields, as follows:

The **source** fields can only be used if the **context** is "mo". It must be the value of a managed-object's global identifier 
(sometimes referred to as a 'device id' or 'source id'). This is used to target inclusion of messages from the given managed-object.

**subscription** is the first of two fields that identify which topic this subscription will forward messages to.
Multiple subscriptions can contribute a single topic if they have they same values for both topic identifying fields.

The **nonPersistent** field determines if the topic is [persistent or nonPersistent](../notifications/#non-persistent-topics).
Subscriptions with the same **subscription** field value, but different **nonPersistent** values forward to two different topics.
It is, therefore, the second of the two fields that identify the subscription topic. 

The **filter** fields can provide a [subscription filter](../notifications/#subscription-filter), allowing more finely 
grained selection of the included messages, based upon the message's type and its API (is it a measurement or alarm, for example). 

The **fragmentsToCopy** field allows the forwarded messages to be transformed so that they contain only a specific subset
of the fragments present in the original {{< product-c8y-iot >}} messages they are generated from. This can be useful, for example,
for security, bandwidth saving or functionality scoping reasons. 

The following summarizes the subscription fields.
<table>
<thead>
<tr>
<th nowrap="nowrap">Field Name&nbsp;</th>
<th>Value</th>
<th>Required/Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td nowrap="nowrap">context</td>
<td>"mo" or "tenant"</td>
<td>Required</td>
<td>Only values "mo" and "tenant" are supported</td>
</tr>
<tr>
<td nowrap="nowrap">source</td>
<td>A managed object global identifier</td>
<td>Required if context is "mo"</td>
<td></td>
</tr>
<tr>
<td nowrap="nowrap">subscription</td>
<td>String</td>
<td>Required</td>
<td>Determines messaging-service topic used</td>
</tr>
<tr>
<td nowrap="nowrap">nonPersistent</td>
<td>Boolean</td>
<td>false</td>
<td>Determines if a persistent or non-persistent topic is used</td>
</tr>
<tr>
<td nowrap="nowrap">filter</td>
<td>JSON object</td>
<td>All messages</td>
<td>Includes messages based on message values</td>
</tr>
<tr>
<td nowrap="nowrap">fragmentsToCopy</td>
<td>JSON list of strings</td>
<td>All fragments</td>
<td>Determines which fragments are included in forwarded messages.</td>
</tr>
</tbody>
</table>

<a name="subscription-filter">&nbsp;</a>
### Subscription filters
Subscription filters provide fine-grained selection of the {{< product-c8y-iot >}} messages a subscription will forward.
Filters can be provided as the **subscriptionFilter** field in a subscription's JSON object at creation time. 
It is a JSON object with **apis** and **typeFilter** fields.  
Filters specified by subscriptions with "tenant" **context** *must* provide a **typeFilter** value.
Filters specified by those with "mo" **context** can provide either or both filter fields.

The **apis** field is a JSON array that specifies which {{< product-c8y-iot >}} API messages to include.
To include messages from all APIs use an array containing just the wildcard value, "*". 
To include messages from a selection of the APIs only use an array containing any single or multiple selection from 
"alarms", "alarms with children", "events", "events with children", "measurements", "managed objects" and "operations".

For example, to include only measurements and alarms:
```json
{
  "context": "mo",
  "subscription": "north-system",
  "source": 2468,
  "filter": {
    "apis": ["measurement", "alarm"]
  }
}
```

The "alarms with children" and "events with children" **api** values allow subscriptions with managed-object **context**
to filter in, respectively, alarms or events for all recursively descendant child managed-objects of the **source**
managed-object in addition to inclusion of those from the **source** managed-object itself.

The **typeFilter** string field is matched against the original message's **type** field. It can be a single value, or a
limited (supporting only `or`) [OData](https://en.wikipedia.org/wiki/Open_Data_Protocol) expression.

`TODO` how should quotes be used below

For example, to include messages of **type** "temperature" and messages of **type** "pressure":
```json
{
  "context": "mo",
  "subscription": "north-system",
  "source": 2468,
  "filter": {
    "type": "'temperature' or 'pressure'"
  }
}
```
To include messages of **type** "temperature" only:
```json
{
  "context": "mo",
  "subscription": "north-system",
  "source": 2468,
  "filter": {
    "type": "temperature"
  }
}
```



### TODO somewhere
This API requires the calling user to be an authenticated {{< product-c8y-iot >}} user and to have the new ROLE_NOTIFICATION_2_ADMIN role.

Creations of managed objects, which generate a new object identifier that can act as a source for notifications are reported in the tenant context. 
This allows an application to discover a new managed object, which can then choose to subscribe to in the managed object context.
It is also possible to subscribe to all alarms or events that are generated in the tenant context.

For the protocol consumer, both managed object creations and alarms subscribed under the tenant context are reported in the same way.
There is no distinction between the two contexts for consumers, and notification ordering is maintained between the two contexts.


### Subscription topics TODO

It forms part of the
topic name.
Topic names take the form "<TENANT>/relnotif/<SUBSCRIPTION>", where "<TENANT>" is the tenant's id and
"<SUBCRIPTION>" the value of the **subscription** field. The **nonPersistent** field, following, also can affect an implicit
default part of the topic name.

Within the messaging service, topic names derived from the **subscription** field, as above, are prefixed with a
[scheme](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) that identifies whether a topic is persistent
or non-persistent. The **nonPersistent** field determines which of these two schemes is applied, defaulting to persistent.  
Therefore, for example, the topic "t1234/relnotif/temperature" is the same topic as "persistent://t1234/relnotif/temperature".
Non-persistent topics can only be identified by their complete name including the scheme, for example "non-persistent://t1234/relnotif/temperature"


<a name="non-persistent-topics"/>"
### Non-persistent subscriptions 

When you create a subscription, you can add the optional Boolean body parameter `nonPersistent` to the request.
If it is set to `true`, the created subscription is non-persistent.
If it is not present or `false`, the subscription will be persistent.

Persistent subscriptions ensure that consumers never miss a message if their connection is interrupted.
They use replicated secondary storage to maintain large backlogs (within the constraints of any configured backlog limits)
and to maintain the consumers' positions in subscription notification streams.
When a consumer of a persistent subscription has their connection interrupted,
whether that is due to network issues or deliberate actions by the consumer,
upon reconnection they will continue to receive notifications from the position they were at before the outage
(specifically, from the message after the last one they acknowledged successfully before the outage).

Non-persistent subscriptions are only buffered in memory and their consumers' positions are not persisted across disconnections of the consumer.
When a consumer of a non-persistent subscription has their connection interrupted,
upon reconnection they will start receiving notifications from the most recent message of the subscription,
missing all other notifications that occurred during the connection outage.
This will be the case for such temporarily disconnected consumers,
even if other consumers of the same non-persistent subscription
are still receiving older messages that occurred while it was not connected.

If you create both a persistent and a non-persistent subscription with the same name, that is, with the same `subscription` body parameter value in the request,
they are *separate*, independent subscriptions. Such subscriptions can vary by any other body parameters you choose. They do not have to be
persistent and non-persistent variations of the same notification data. However, we recommend you to keep such subscriptions identical except for the `nonPersistent` parameter to avoid confusion.

When a consumer creates a token for either a persistent or non-persistent subscription,
it must distinguish which type of subscription it is targeting by using the `non-persistent` body parameter in the token creation request.
For the subscription, this body parameter defaults to `false`, making the token target a persistent subscription.
Setting the body parameter to `true` in the token creation request targets a non-persistent subscription.

### Receiving subscribed notifications

In order to receive subscribed notifications, a consumer application or microservice must obtain an authorization token that provides proof that the holder is allowed to receive subscribed notifications.

This token is in the form of a string conforming to the JWT (JSON Web Token) standard that is obtained from the [token method](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#tag/Tokens) of the Notifications 2.0 API.
This API requires the calling user to be an authenticated {{< product-c8y-iot >}} user and to have the new ROLE_NOTIFICATION_2_ADMIN role.

See the [{{< openapi >}}](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#tag/Tokens) for both the Notification 2.0 Subscription and Token API.

Once subscribed, notifications are persisted and available to be consumed using a new WebSocket-based protocol.
This protocol implements a reliable delivery with at-least-once semantics.
The underlying Messaging Service will repeatedly attempt to deliver a notification until that notification is acknowledged as being received and processed by the consuming application or microservice.
Notification order is preserved from the point of view of a device sending in REST and MQTT API requests.
The protocol is text-based and described in detail in the next section.


### Token expiration

When creating a token, an expiration time must be given in minutes of validity from when the token was created.
This security feature limits the potential damage due to leaking of a token.
It requires tokens to be re-created or refreshed periodically.
This can be done by calling the token create request with the same parameters as originally.
If the parameters used are not available they can be extracted from the token.
As the token string is a JWT (JSON Web Token), it can be decoded to extract the original information used to create the token by splitting it into 3 parts (on ".") and doing a base64 decode on the first substring.
This way, information like the subscription name can be extracted and the create token REST point can be called again, all on the client side.
The {{< product-c8y-iot >}} microservice Java SDK [TokenApi](https://github.com/SoftwareAG/cumulocity-clients-java/blob/develop/java-client/src/main/java/com/cumulocity/sdk/client/messaging/notifications/TokenApi.java) class contains a public refresh method which is implemented purely on the client side.

### Shared tokens

Shared tokens allow parallelization of the consumer client workload for a notification subscription.
This is useful if the notifications would otherwise arrive at a higher rate than the consuming client application can process them.
It has no impact on the rate of notification throughput within, and thus their egress from, {{< product-c8y-iot >}} core.

When you create a token, you can add the optional Boolean body parameter `shared` to the request.
If it is set to `true`, the created token is shared.
If it is not present or `false`, the token is exclusive (not shared).

If a consumer's token is not shared, the consumer is an *exclusive* consumer.
Only one consumer client can connect using an exclusive token. An attempt to connect further consumers with the same exclusive token results in an error.
An exclusive consumer receives a copy of all notifications from the subscription its token is for.

If a consumer's token is shared, the consumer is a *shared consumer*. Additional consumer clients can connect using the same token.
If only one shared consumer is connected, it receives a copy of all notifications from the subscription.
As additional consumer clients connect using the same token, the consumers' notification load is rebalanced so that 
each consumer receives a non-overlapping subset (share) of the notifications from the subscription. 
The set of consumers sharing a token can be thought of as a single logical consumer.
Collectively, the set receives all notifications for the subscription. 

The notification load is spread across the shared consumers according to the ID of the source that generated the notification, typically a device ID.
All notifications for a given ID will be delivered to the same consumer. Each consumer may receive notifications for many different IDs.
This means that there is no benefit using shared tokens unless the notifications feeding the subscription are coming from multiple sources.
Note that the load spreading algorithm may result in an asymmetric balance of notification load across the shares when there are few source IDs in the subscription.
The load should generally become more evenly distributed as the number of sources increases.

In order to help keep the messages from a given set of source IDs stick to shared consumers in the face of connection interruptions, the consumer clients can provide an 
optional `consumer` parameter in their connection URL string, in addition to their usual `token` parameter. 

For example: two consumers identifying themselves as *instance1* and *instance2* connect using URL paths
`notification2/consumer?token=xyz&consumer=instance1` and `notification2/consumer?token=xyz&consumer=instance2`.

Subscriptions are always unaware of the nature and number of their consumers: any number of shared and exclusive tokens can be created for the same subscription and they all operate independently, each receiving their own copy of the notifications. This means you can have multiple shared tokens for the same subscription and their load is only divided within the scope of each shared token.

### Deleting subscriptions and unsubscribing a subscriber

Once a subscription is made, notifications will be retained until consumed by all subscribers who have previously connected to the subscription.
The normal workflow is to delete subscriptions when no longer interested in notifications and this is the resonsibility of the subscriber. 
The subscription API [{{< openapi >}}](https://{{<domain-c8y>}}/api/{{< c8y-current-version >}}/#tag/Subscriptions) is used to delete subscriptions.
After the subscription is deleted no more notifications will be saved. The consuming microservice or application can then drain down notifications 
and be removed when that is done.

Once a subscription is made, notifications will be kept until consumed by all subscribers who have previously connected to the subscription.
For persistent subscriptions, this can result in notifications remaining in storage if never consumed by the application.
However, unconsumed persistent notifications will be retained, and for high throughput scenarios this can result in notifications remaining in storage if never consumed by the application.

They will be deleted if a tenant is deleted but otherwise can take up considerable space in permanent storage for high frequency notification sources.
It is therefore advisable to unsubscribe a subscriber that will never run again (and so will not drain down persisted notifications).
A separate REST endpoint is available for this: <kbd>/notification2/unsubscribe</kbd>.
It has a mandatory query parameter `token`.
The token is the same as you would use to connect to the WebSocket endpoint to consume notifications.
Note that there is no explicit "subscribe a subscriber" operation using a token.
Instead this happens when you first connect a WebSocket with a token for the subscription name and subscriber.
However, unsubscribing a microservice or an application is an explicit act using the original or a similar token.
Unsubscribing should be infrequent, for example when deleting an application or during development when testing completes,
as typically one wants messages to persist even when no consumer is running.
Only if no consumer will ever run again to drain notifications should unsubscribing a subscriber be necessary.

It is also possible to unsubscribe a subscriber on an open consumer WebSocket connection.
To do so, send `unsubscribe_subscriber` instead of a message acknowledgement identifier from your WebSocket client to the service.
The service will then unsubscribe the subscriber and close the connection.
It's not possible to check if the unsubscribe operation succeeded as the connection always closes so this way of unsubscribing is mostly for testing.

It is always important to delete subscriptions (Delete operations on `/notification2/subscriptions`) even having unsubscribed, 
as otherwise notifications will be generated even if no subscriptions remain. While they would not persist, load and network traffic would still be incurred.

### Building consuming microservices and applications

For Java developers, the API and the protocol have been wrapped up as an open Java API and a sample WebSocket client application. Any WebSocket library or programming language can be used as the protocol is text-based and relatively simple. Consumer can be either microservices or applications running externally from {{< product-c8y-iot >}} and require only a JWT string when connecting.

There is a sample microservice available in the [cumulocity-examples repository](https://github.com/SoftwareAG/cumulocity-examples/tree/develop/hello-world-notification-microservice), so Java developers do not need to code to the protocol specification directly.
